# 3. Декоратор с параметрами
# До этого мы вкладывали одну функцию в другую для создания замыкания. Если мы
# хотим передавать в декоратор дополнительные параметры, понадобится третий
# уровень вложенности. Рассмотрим пример кода.
#
#
# import time
# from typing import Callable
#
# def count(num: int = 1):
#     def deco(func: Callable):
#         def wrapper(*args, **kwargs):
#             time_for_count = []
#             result = None
#             for _ in range(num):
#                 start = time.perf_counter()
#                 result = func(*args, **kwargs)
#                 stop = time.perf_counter()
#                 time_for_count.append(stop - start)
#             print(f'Результаты замеров {time_for_count}')
#             return result
#         return wrapper
#     return deco
#
#
#
# @count(10)
# def factorial(n: int) -> int:
#     f = 1
#     for i in range(2, n + 1):
#         f *= i
#     return f
#
#
# print(f'{factorial(1000) = }')
# print(f'{factorial(1000) = }')
#
# ● Внешняя функция count принимает на вход целое число num. Данный
# параметр будет использован для цикла for.
# ● Функция deco как и в прошлых примерах принимает декларируемую
# функцию.
# ● Внутренняя функция wrapper создаёт список time_for_count для хранения
# результатов замеров быстродействия.
# ○ Запускаем цикл for столько раз, сколько мы передали в декоратор:
# @count(10)
# ○ Внутри цикла for замеряем текущее время. Далее выполняем функцию
# и сохраняем результат в переменную. Замеряем время после
# окончания работы функции и сохраняем разницу в список.
# ○ После завершения цикла сообщаем результаты из списка
# time_for_count и возвращаем результат работы декларируемой
# функции.
# ● Используя обёртку для факториала делаем 10 замеров и смотрим время на
# вычисления.
# 🔥 Важно! Последняя строка дублируется не случайно. Каждый из двух
# запусков делает по 10 замеров. Если бы список time_for_count был создан на
# уровень выше, в функции deco, произошло бы его замыкание. В результате
# каждый новый вызов функции factorial дополнял бы уже существующий список,
# а не создавал бы новые 10 значений.
# Декоратор с параметром может принимать любые значения в зависимости от
# предназначения.
# 🔥 Важно! Для оценки быстродействия кода рекомендуется использовать
# модуль timeit из “батареек Python”, а не созданный выше декоратор.
#
#
#
# Задание
# Перед вами несколько строк кода. Напишите что выведет программа, не запуская
# код. У вас 3 минуты.

# import random
# from typing import Callable
#
#
# def count(num: int = 1):
#     def deco(func: Callable):
#         counter = []
#         def wrapper(*args, **kwargs):
#             for _ in range(num):
#                 result = func(*args, **kwargs)
#                 counter.append(result)
#             return counter
#         return wrapper
#     return deco
#
#
# @count(10)
# def rnd(a: int, b: int) -> int:
#     return random.randint(a, b)
#
#
# print(f'{rnd(1, 10) = }')
# print(f'{rnd(1, 100) = }')
# print(f'{rnd(1, 1000) = }')
#
# Вывод:
# rnd(1, 10) = [8, 9, 8, 8, 4, 2, 8, 2, 3, 4]
# rnd(1, 100) = [8, 9, 8, 8, 4, 2, 8, 2, 3, 4, 61, 72, 78, 60, 30, 39, 39, 24, 94, 92]
# rnd(1, 1000) = [8, 9, 8, 8, 4, 2, 8, 2, 3, 4, 61, 72, 78, 60, 30, 39, 39, 24, 94, 92, 537, 860, 850, 899, 447, 221, 677, 116, 573, 23]