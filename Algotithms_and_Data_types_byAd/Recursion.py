# Метод решения задач - рекурсия(метод программирования используемый во многих алгоритмах(к примеру в стратегии разделяй и властвуй, алгоритм быстрой сортировки))
# Рекурсия - один из способов заменить итерацию
# Рекурсией называется вызов функцией самой себя
# Базовый случай - описывает ситуацию выхода из рекурсии(УСЛОВИЕ ЗАВЕРШЕНИЕ РЕКУРСИИ)
# Рекурсивный шаг - вызов функции самой себя(как правило каждый вызов приближает к базовому случаю)
# При рекурсии сохраняется состояние в стеке вызовов(все значения переменных  функции остаются в памяти)
def countdown(i):
    print(i)
    if i <= 1:  # Базовый случай условие завершения рекурсии
        return
    else:
        countdown(i - 1)  # рекурсивный вызов


# Реализуется за счет структуры данных СТЕК(LIFO Last In First Out)
# Рекурсивные функции используют стек вызовов.
# Если нет базового случая - стек переполняется (ошибка StackOwerflow)


# Рекурсивный факториал
def fact(n):
    if n == 1:  # Базовый случай условие завершения рекурсии
        return 1

    return fact(n - 1) * n  # рекурсивный вызов(как происходит изменение аргумента вызова, чтобы при новом вызове приблизится к базовому случаю)


# Итерация
# ИТЕРАЦИЯ - организация обработки данных, при которой действия выполняются многократно
# def fact(n: int) -> int:
#     product = 1
#     for i in range(2, n + 1):
#         product *= i
#     return product


# Если пишете рекрсивную функцию в которой задействован массив, базовый случай - пустой массив или массив из одного элемента!
#
# Алгоритмы использующие стратегию (разделяй и властвуй) используют рекурсию
# Разделяй и властвуй стратегия состоит из двух шагов:
# 1 Сначала опред базовый случай - простейший из всех возможных
# 2 Задача сокращается пока не будет сведена к базовому случаю


# Рекурсивный алгоритм нахождения суммы в списке
# def sum_(numbers: list) -> int:
#     if not numbers:
#         return 0
#     else:
#         return numbers[0] + sum_(numbers[1:])
#
#
# print(sum_([1, 2, 3, 4, 5]))

# a = [1,2,3,4,5]
# print(a[:-1])


# Рекурсивный алгоритм для подсчета элементов в списке(массиве)
# def rec_count_el(array: list) -> int:
#     if not array:
#         return 0
#     else:
#         return 1 + rec_count_el(array[1:])
#
# print(rec_count_el([1, 2, 3, 4, 5, 6, 7, 10, 12]))


# Рекурсивный алгоритм нахождения наибольшего числа в списке
def max_num(array: list) -> int:
    if len(array) == 2:
        return array[0] if array[0] > array[1] else array[1]
    else:
        return array[0] if array[0] > max_num(array[1:]) else max_num(array[1:])



print(max_num([1, 2, 3, 56, 5, 6, 7, 10, 12]))
