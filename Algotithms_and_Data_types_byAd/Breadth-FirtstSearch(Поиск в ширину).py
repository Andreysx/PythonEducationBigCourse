# # Поиск в ширину работает только с графами.
# Граф состоит из узлов и ребер(абстрактная структура данных).
# Отношения между узлами могут действовать только в одну сторону(направленные).
# Направленный граф - разновидность графа - Дерево(абстрактная структура данных)
# Либо отношения действовуют в обе стороны(ненаправленные, каждый узел является соседом по отношению к другому)
# Графы реализуются на базе хеш-таблиц.


# Реализация направленного графа на базе хеш-таблицы(dict)
# Хэш-таблицы позволяют смоделировать отношения между объектами

graph = dict()
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

#
# Полный алгоритм поиска в ширину(работает с deque двусторонней очередью(двусвязным списком) Python).
# Сложность алгоритма O(V+E) V - количеество вершин Е - количество ребер.
# Алгоритм проверяет сначала связи первого уровня, затем связи второго уровня, затем третьего и тд.
# Поиск в ширину распространяется от начальной точки
# Поиск в ширину позволяет определять существует ли путь из A в B
# Если путь существует, поиск в ширину определяет кратчайший путь

from collections import deque


def person_is_seller(name):  # простая функция для поиска узла(нужного узла) с оканчивающимся именем на м
    return name[-1] == 'm'


# Алгоритм поиска в ширину

def search(name):
    search_queue = deque()  # Создание пустой очереди
    search_queue += graph[name]  # Все соседи добавляются в очередь из списка
    searched = []  # Массив для отслеживания уже проверенных узлов
    while search_queue:  # Пока очередь не пуста
        person = search_queue.popleft()  # Из очереди извлекается первый элемент
        if not person in searched:  # Узел проверяется только в том случае если он не проверялся ранее
            if person_is_seller(person):  # Проверяем узел на правдивость
                print(f'Found {person}')  # Да это то что искали
                return True
            else:
                search_queue += graph[person]  # Добавляются все соседи проверяемого узла
                searched.append(person)  # Узел помечается как уже проверенный
    return False  # Если выполнение дошло до этой строки, значит в графе нет искомого элемента


search('you')
