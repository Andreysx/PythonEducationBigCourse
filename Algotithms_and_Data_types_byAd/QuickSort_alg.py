# Быстрая сортировка
# Быстрая сортировка использует стратегию разделяй и властвуй основанную на рекурсии
# Стратегия разделяй и властвуй:
# 1.Определите простейший случай как базовый(простейший случай из всех возможных)
# 2.Придумайте, как свести задачу к базовому случаю(задача делится или сокращаетсяя до тех пор, пока не будет сведена к базовому случаю)
# Принцип работы Алгоритма:
# 1. Определяется базовый случай(пустой массив или массив из одного элемента)
# 1. Сначала выбирается опорный элемент в массиве(лучше центральный)
# 2.Определяется подмассив меньше опорного элемента
# 3.Определяется подмассив больше опорного элемента
# 4.К каждому подмассиву рекурсивно применяется функция сортировки пока не дойдет до БАЗОВОГО СЛУЧАЯ(простейшего случая из всех возмоджных)(Рекурсивный шаг)


from time import time
import random

# Если использовать в качестве опорного элемента первый элемент - то скорее всего сложность алгоритма будет квадратичная худший случай O(n2)
# К примеру если поступает отсортированный массив  - бастрая сортировка не проверяет отсортирован ли он и проходит по порядку по всем элементам
def quicksort(array: list):
    if len(array) < 2:  # Базовый случай массивы с 0 и 1 элементами уже отсортированы
        return array
    else:
        pivot = array[0]  # Опорный элемент - первый элемент
        less = [i for i in array[1:] if
                i < pivot]  # Подмассив элементов меньших опорного(применяется List comprehension)
        greater = [i for i in array[1:] if
                   i > pivot]  # Подмассив элементов больших опорного(применяется List comprehension)
        return quicksort(less) + [pivot] + quicksort(greater)

# Если использовать в качестве опорного элемента центральный(случайный) элемент то каждый сложность алгортима будет средним случаем O(n log n)
def quicksort_2(array: list):
    if len(array) < 2:  # Базовый случай массивы с 0 и 1 элементами уже отсортированы
        return array
    else:
        pivot = array[(len(array) - 1) // 2]  # Опорный элемент - центральный элемент
        less = [i for i in array if
                i < pivot]  # Подмассив элементов меньших опорного(применяется List comprehension)
        greater = [i for i in array if
                   i > pivot]  # Подмассив элементов больших опорного(применяется List comprehension)
        return quicksort(less) + [pivot] + quicksort(greater)


#
start = time()
quicksort([random.randint(1, 10) for _ in range(1000000)])
# print(quicksort([random.randint(1, 10) for _ in range(1000000)]))
end = time()

start_2 = time()
quicksort_2([random.randint(1, 10) for _ in range(1000000)])
# print(quicksort([random.randint(1, 10) for _ in range(1000000)]))
end_2 = time()

print(f'Время выполнения быстрой сортировки где опорный элемент - первый (Худший случай) {end - start}')
print(f'Время выполнения быстрой сортировки где опорный элемент - центральный(случайный)(Средний случай) {end_2 - start_2}')

