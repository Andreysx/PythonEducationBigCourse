# Метод copy()
# Метод copy создаёт поверхностную копию списка. Начнём с плохого примера, чтобы
# понять пользу копий.
# my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# new_list = my_list
# print(my_list, new_list, sep='\n')
# my_list[2] = 555
# print(my_list, new_list, sep='\n')
# Мы скопировали в переменную new_list указатель на список my_list. Далее мы
# изменили элемент в исходном списке. Новый список также оказался изменённым.
# Как вы помните list — изменяемый тип данных и подобное поведение нормально.
# Что делать, если нужно менять оригинал, но не затрагивать копию. Верно. Метод
# copy.
# 16
# my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# new_list = my_list.copy()
# print(my_list, new_list, sep='\n')
# my_list[2] = 555
# print(my_list, new_list, sep='\n')
# Теперь изменяется лишь один список.
# Зачем нужна функция copy.deepcopy()
# Иногда программисту приходится работать с вложенными друг в друга
# коллекциями. Например матрица или список списков.
# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# new_m = matrix.copy()
# print(matrix, new_m, sep='\n')
# matrix[0][1] = 555
# print(matrix, new_m, sep='\n')
# Метод copy создал поверхностную копию, копию верхнего уровня. Изменения же
# вложенных объектов отразится и на оригинале. В таком случае для создания
# полной копии любой глубины вложенности используют функцию deepcopy из
# модуля copy.
# import copy
# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# new_m = copy.deepcopy(matrix)
# print(matrix, new_m, sep='\n')
# matrix[0][1] = 555
# print(matrix, new_m, sep='\n')
# Функция рекурсивно обходит все вложенные объекты создавая их копии.
# Изменения одной коллекции теперь не затрагивают её копию.
# 17
# Плюсы и минусы создания копии
# При работе со списками важно помнить, что сам список как хранитель указателей
# на объекты занимает место в памяти. Дополнительно занимают память и сами
# объекты, на которые список указывает. Создание копии приводит к новым затратам
# памяти, ведь мы создаём новый объект список. Если вы работает с большими
# данными, создание копии может быть не лучшей идеей - может не хватить памяти
# ПК. Кроме того каждая копия требует временных ресурсов на копирование. Прежде
# чем использовать срезы, копии задумайтесь можно ли решить задачу иначе,
# экономя время и память.
# С другой стороны небольшие списки быстро копируются. И если в вашей задаче
# важно сохранить оригинал, но нужно модифицировать список для получения
# результата — копирование вполне допустимо.
