# Области видимости: global и nonlocal
# Хорошая функция работает как чёрный ящик. Использует только переданные ей
# значения и возвращает ответ. Но в Python функции могут обращаться к внешним
# переменным без явной передачи в качестве аргумента.
# В Python есть несколько областей видимости:
# ● локальная — код внутри самой функции, т.е. переменные заданные в теле
# функции.
# ● глобальная — код модуля, т.е. переменные заданные в файле py содержащем
# функцию.
# ● не локальная — код внешней функции, исключающий доступ к глобальным
# переменным.
# Разберем на примерах.
# ● Локальные переменные:
#
# def func(y: int) -> int:
#     x = 100
#     print(f'In func {x = }') # Для демонстрации работы, но не для привычки принтить из функции
#     return y + 1
#
# x = 42
# print(f'In main {x = }')
# z = func(x)
# print(f'{x = }\t{z = }')
#
# Переменная x в теле функции и переменная x в основном коде - две разные
# переменные. Локальная область видимости функции создала свою переменную.
# Попробуем для эксперимента заменить строку с иксом на x += 100 В результате
# получаем ошибку UnboundLocalError: local variable 'x' referenced before assignment.
# Функция не смогла увеличить 42 на 100, т.к. переменные лишь для нас выглядят
# одинаково. Чёрный ящик не увидел x без его явной передачи в функцию.
# ● Глобальные переменные:
#
# def func(y: int) -> int:
#     global x
#     x += 100
#     print(f'In func {x = }') # Для демонстрации работы, но не для привычки принтить из функции
#     return y + 1
#
# x = 42
# print(f'In main {x = }')
# z = func(x)
# print(f'{x = }\t{z = }')
#
#
# Теперь переменная x в теле функции объявлена как глобальная. Мы получили
# доступ к внешнему иксу со значением 42 и смогли его увеличить. Изменение
# затронуло как внешний, так и внутренний икс.
# Важно! Не стоит злоупотреблять командой global. В 9 из 10 случаев переменную
# стоит передать как аргумент в функцию и вернуть ответ.
# ● Не локальные переменные:
#
# def main(a):
#     x = 1
#     def func(y):
#         nonlocal x
#         x += 100
#         print(f'In func {x = }') # Для демонстрации работы, но не для привычки принтить из функции
#         return y + 1
#     return x + func(a)
#
# x = 42
# print(f'In main {x = }')
# z = main(x)
# print(f'{x = }\t{z = }')
#
# Функция func вложена в функцию main. Благодаря команде nonlocal мы смогли
# получить доступ к x = 1. В результат внутри func x увеличился до 101. В отличии от
# команды global, мы не смогли увидеть внешний x = 42. nonlocal позволяет заглянуть
# на верхний уровень вложенности, но не выходить на глобальные переменные
# модуля.
#
# Доступ к константам
# Один из случаев когда обращение из тела функции к глобальной переменной
# считается нормальным — доступ к константам.
#
# LIMIT = 1_000
# def func(x, y):
#     result = x ** y % LIMIT
#     return result
#
# print(func(42, 73))
#
# Константа LIMIT является глобальной. При обращении к ней из функции
# производится поиск в локальной области, т.е. в теле функции. Далее поиск
# переходит на уровень выше, в глобальную область видимости модуля. Чтение
# значений констант внутри функции будет работать без ошибок.
